import React from 'react';
import ReactDOM from 'react-dom';

import { Slot } from '../slot/slot';

const NODES = [
  'a',
  'button',
  'div',
  'form',
  'h2',
  'h3',
  'img',
  'input',
  'label',
  'li',
  'nav',
  'ol',
  'p',
  'span',
  'svg',
  'ul',
] as const;

type PropsWithoutRef<P> = P extends any
  ? 'ref' extends keyof P
    ? Pick<P, Exclude<keyof P, 'ref'>>
    : P
  : P;
type ComponentPropsWithoutRef<T extends React.ElementType> = PropsWithoutRef<
  React.ComponentProps<T>
>;

type Primitives = {
  [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E>;
};
type PrimitivePropsWithRef<E extends React.ElementType> =
  React.ComponentPropsWithRef<E> & { asChild?: boolean };

interface PrimitiveForwardRefComponent<E extends React.ElementType>
  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}

/* -------------------------------------------------------------------------------------------------
 * Primitive
 * -----------------------------------------------------------------------------------------------*/

const Primitive = NODES.reduce((primitive, node) => {
  const Node = React.forwardRef(
    (props: PrimitivePropsWithRef<typeof node>, forwardedRef) => {
      const { asChild, children, ...primitiveProps } = props;

      const Comp: any = asChild ? Slot : node;

      return (
        <Comp
          {...primitiveProps}
          ref={forwardedRef}
        >
          {children}
        </Comp>
      );
    },
  );

  Node.displayName = `Primitive.${node}`;

  return { ...primitive, [node]: Node };
}, {} as Primitives);

/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/

/**
 * Flush custom event dispatch
 * https://github.com/radix-ui/primitives/pull/1378
 *
 * React batches *all* event handlers since version 18, this introduces certain
 * considerations when using custom event types.
 *
 * Initially an event can be triggered by the user action e.g. clicking the
 * mouse button or tapping keyboard, or generated by APIs to represent the
 * progress of an asynchronous task. It can also be triggered by calling the
 * `HTMLElement.click()` method of an element, or by defining the event, then
 * sending it to a specified target using `EventTarget.dispatchEvent()`
 *
 * Internally, React prioritizes events in the following order:
 *  - Discrete: These events represent user interactions that typically result
 *    in a clear change in the UI state. They are often momentary and have a
 *    well-defined start and end point. Discrete events are considered
 *    high-priority because they directly affect the user's perception of the
 *    application's responsiveness. React aims to handle them promptly to
 *    maintain a smooth user experience without noticeable delays between the
 *    interaction and the corresponding UI update.
 *    Examples:
 *      - Clicks (click)
 *      - Key presses (keydown, keyup)
 *      - Form submissions (submit)
 *      - Focus changes (focusin, focusout)
 *      - Mouse button events (mousedown, mouseup)
 *      - Touch events (touchstart, touchend)
 *
 *  - Continuous: These events represent ongoing user interactions that may
 *    generate a stream of data or updates as long as the interaction continues.
 *    They often involve movement or continuous input. React assign a lower
 *    priority to continuous events compared to discrete events. While
 *    continuous events are still processed, they might be batched together and
 *    handled less frequently to optimize performance. This is because
 *    continuous updates may not require immediate UI changes, and grouping them
 *    can improve rendering efficiency.
 *    Examples:
 *      - Mouse movements (mouseover, mouseout, mousemove)
 *      - Scrolling (scroll)
 *      - Dragging (drag, dragenter, dragexit, dragover, dragleave)
 *      - Touch moves (touchmove)
 *      - Wheel events (wheel)
 *
 *  - Default: This category encompasses all event types not explicitly
 *    classified as discrete or continuous. Default events receive a medium
 *    priority by default, balancing responsiveness with performance
 *    considerations. If a specific event has a known behavior
 *    (discrete or continuous), you might adjust its priority accordingly for
 *    optimal handling.
 *    Examples:
 *      - Less common events like 'message' (which can have varying priority
 *        depending on the scheduler context)
 *      - Events you might define in your custom components
 *
 * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L291-L396
 *
 * The 'discrete' event type is a important distinction as updates within these
 * events are applied immediately. React, however, is not able to infer the
 * priority of custom event types due to how they are detected internally.
 * Because of this, it's possible for updates from custom events to be
 * unexpectedly batched when  dispatched by another 'discrete' event.
 *
 * In order to ensure that updates from custom events are applied predictably,
 * we need to manually flush the batch. This utility should be used when
 * dispatching a custom event from within another 'discrete' event. This utility
 * is not necessary when dispatching known event types, or if dispatching a
 * custom type inside a non-discrete event.
 *
 * For example:
 *    - Dispatching a known click ðŸ‘ŽðŸ»:
 *        target.dispatchEvent(new Event('click'))
 *
 *    - Dispatching a custom type within a non-discrete event ðŸ‘ŽðŸ»:
 *        onScroll={(event) => event.target.dispatchEvent(new CustomEvent('customType'))}
 *
 *    - Dispatching a custom type within a 'discrete' event ðŸ‘ðŸ»:
 *        onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent('customType'))}
 *
 * Note: though React classifies 'focus', 'focusin' and 'focusout' events as
 * 'discrete', it's not recommended to use this utility with them. This is
 * because it's possible for those handlers to be called implicitly during
 * render. Example: when focus is within a component as it is unmounted, or when
 * managing focus on mount.
 */

function dispatchDiscreteCustomEvent<E extends CustomEvent>(
  target: E['target'],
  event: E,
) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

/* -----------------------------------------------------------------------------------------------*/

export { dispatchDiscreteCustomEvent, Primitive };

export type { ComponentPropsWithoutRef, PrimitivePropsWithRef };
